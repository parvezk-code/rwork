# -*- coding: utf-8 -*-
"""KNN_Classifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bxtyX-1PGJ7P8-HfAk6iAQaHB89PD8W0
"""

'''
KNN chooses K nearest data items for the data set.

It does prediction based on these k neighbours of the input

'''

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix
from sklearn.datasets import fetch_openml

class KnnClassifier:
    def __init__(self, data, k, train_size):
        # Initialize with data and split into X (independent) and Y (dependent)
        self.df           =   data
        self.X            =   self.df.drop(columns='target')
        self.Y            =   self.df['target']
        self.X_train      =   None
        self.Y_train      =   None
        self.X_test       =   None
        self.Y_test       =   None
        self.Y_pred       =   None
        self.train_size    =   train_size
        self.k            =   k
        self.knn_model    =   KNeighborsClassifier(self.k)
        self.accuracy     =   None
        self.precision    =   None
        self.f1_Score     =   None
        self.specificity  =   None
        self.serendipity  =   None
        self.recall_sensitivity  =   None

    # Split data into training and test sets
    def splitData(self):

        # Split into training and testing sets
        self.X_train, self.X_test, self.Y_train, self.Y_test = train_test_split(self.X, self.Y, train_size=self.train_size, random_state=42)

        # Normalize/Standardize features (important for KNN)
        scaler = StandardScaler()
        self.X_train = scaler.fit_transform(self.X_train)
        self.X_test = scaler.transform(self.X_test)



    def fit(self):
        self.knn_model.fit(self.X_train, self.Y_train)

    def predict(self):
        self.Y_pred = self.knn_model.predict(self.X_test)

    def print_coefficients(self):
        print("")

    def evaluate_model(self):
        # Calculate metrics
        self.accuracy = accuracy_score(self.Y_test, self.Y_pred)
        self.precision = precision_score(self.Y_test, self.Y_pred, average='weighted')  # Use 'binary' for binary classification
        self.recall_sensitivity = recall_score(self.Y_test, self.Y_pred, average='weighted')
        self.f1_Score = f1_score(self.Y_test, self.Y_pred, average='weighted')

        # Confusion matrix for specificity and sensitivity
        conf_matrix = confusion_matrix(self.Y_test, self.Y_pred)
        tn, fp, fn, tp = conf_matrix.ravel()
        self.specificity = tn / (tn + fp)  # Specificity
        sensitivity = self.recall_sensitivity  # Sensitivity is the same as recall


        # Serendipity (example definition: proportion of unexpected but correct predictions)
        # This is domain-specific and may require custom implementation.
        self.serendipity = (tp / (tp + fp)) * (tp / (tp + fn))  # Example formula

        # Print metrics
        '''
        print(f"Accuracy: {self.accuracy:.4f}")
        print(f"Precision: {self.precision:.4f}")
        print(f"Recall (Sensitivity): {self.recall_sensitivity:.4f}")
        print(f"F1-Score: {self.f1_Score:.4f}")
        print(f"Specificity: {self.specificity:.4f}")
        print(f"Serendipity: {self.serendipity:.4f}")
        print(conf_matrix)
        '''

    def start(self):
      self.splitData()            # create train and test
      self.fit()                  # using X_train, Y_train
      #self.print_coefficients()
      self.predict()              # using X_test
      self.evaluate_model()       # using Y_test, Y_pred

import time

class ModelAnalyzer:
    def __init__(self, train_size, k):
        # Initialize the input list splits
        self.train_size = train_size
        self.k = k
        self.results = []
        #self.results.append([''] + self.splits)
        self.results.append(['Testing Time'] )
        self.results.append(['Training Time'] )
        self.results.append(['Accuracy'] )
        self.results.append(['Precision'] )
        self.results.append(['Recall'] )
        self.results.append(['F1-Score'] )
        self.results.append(['Specificity'] )
        self.results.append(['Serendipity'] )


    def get_table(self):
        # Return the list results
        train_size = ["train % -->"] + self.train_size

        # Create a pandas DataFrame
        df = pd.DataFrame(self.results, columns=train_size)

        # Use pandas styling for a nice table display
        styled_df = df.style.set_table_styles(
            [{'selector': 'thead th',
              'props': [('background-color', '#4CAF50'),
                        ('color', 'white'),
                        ('font-weight', 'bold')]},
            {'selector': 'tbody tr:nth-child(odd)',
              'props': [('background-color', '#f2f2f2')]},
            {'selector': 'tbody tr:nth-child(even)',
              'props': [('background-color', '#ffffff')]},
             {'selector': 'td', 'props': [('text-align', 'left')]}]
        )

        # Display the table
        return(styled_df.hide(axis="index"))

    def storeResult(self, obj):
        self.results[2].append(obj.accuracy)
        self.results[3].append(obj.precision)
        self.results[4].append(obj.recall_sensitivity)
        self.results[5].append(obj.f1_Score)
        self.results[6].append(obj.specificity)
        self.results[7].append(obj.serendipity)

    def start(self):
      heart_disease = fetch_openml(name='heart-disease', version=1, as_frame=True)
      data = heart_disease.frame

      for size in self.train_size:
        obj = KnnClassifier(data, self.k, (0.7 * float(size)) )
        obj.splitData()            # create train and test
        start_time = time.time()
        obj.fit()                  # using X_train, Y_train
        end_time = time.time()
        self.results[1].append(end_time - start_time)
        #self.print_coefficients()
        start_time = time.time()
        obj.predict()              # using X_test
        end_time = time.time()
        self.results[0].append(end_time - start_time)
        obj.evaluate_model()       # using Y_test, Y_pred
        self.storeResult(obj)

# Example usage:
K = 5
train_size = ["0.2", "0.3", "0.4", "0.5", "0.6", "0.7"]
creator = ModelAnalyzer(train_size, K)
creator.start()
creator.get_table()