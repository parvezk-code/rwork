# -*- coding: utf-8 -*-
"""csp_map_coloring.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hwRDyAPKAyHAANiOB60lEk2XP49jK5wP
"""

class MapColoring:
    def __init__(self, adjacency_list:dict, colors:list):
        self.graph = adjacency_list
        self.colors_list = colors
        self.solution = {item: -1 for index, item in enumerate(adjacency_list)}

    # constraint-1
    def checkConstraints(self, region, color_index):
        for neighbor in self.graph.get(region, []):
            if self.solution[neighbor] == color_index:
                return False
        return True

    # getNextPosition: move to next state
    def getNextAvailableColor(self, region):
      nextAvailableColor  =   self.solution[region] + 1
      total_colors        =   len(self.colors_list)

      while(nextAvailableColor<total_colors):
          if(self.checkConstraints(region, nextAvailableColor)):
            return(nextAvailableColor)
          nextAvailableColor += 1

      return(-1)

    def saveSolution(self, region, color):
      self.solution[region] = color

    def backtrack(self, currentRegion):
      self.solution[currentRegion]  = -1

    def convertIndexToColorNames(self):
      for key in self.solution:
        if(self.solution[key] != -1):
          self.solution[key] = self.colors_list[self.solution[key]]
        else:
            self.solution[key] = 'No color'


    def solve(self):

      total_colors        =   len(self.colors_list)
      total_regions       =   len(self.graph)
      list_of_regions     =   [key for key in self.graph]
      currentRegionIndex  =   1
      first_reg           =   list_of_regions[0]
      second_reg          =   list_of_regions[1]
      self.solution[first_reg]    =   0

      while(self.solution[second_reg] < total_colors):
        currentRegion   =  list_of_regions[currentRegionIndex]
        color         =   self.getNextAvailableColor(currentRegion)

        if(color==-1):
            self.backtrack(currentRegion)
            currentRegionIndex -= 1
        elif(currentRegionIndex == total_regions-1):
            self.saveSolution(currentRegion, color)
            return True
        else:
          self.saveSolution(currentRegion, color)
          currentRegionIndex += 1

      return False

adjacency_list = {
        'A': ['B', 'C', 'D'],
        'B': ['A', 'C', 'E'],
        'C': ['A', 'B', 'D', 'E'],
        'D': ['A', 'C', 'E'],
        'E': ['B', 'C', 'D'],
}

colors = ['Red', 'Green', 'Blue']
#colors = ['Red', 'Green']

map_coloring = MapColoring(adjacency_list, colors)
print(map_coloring.solve())
map_coloring.convertIndexToColorNames()
print(map_coloring.solution)

"""1.   constraints
2.   checkConstraints
1.   getNextPosition
1.   saveSolution
1.   backtrack
2.   solve(no solution, goal state, intermediate state)

Magic 3x3 square, each row/col/dig sum is 15
Map coloring
suduku

A magic square contains the integers from 1 to n^2. Sum is = n(n^2+1)/2

https://courses.cs.umbc.edu/671/fall12/notes/06/csp_python.ppt.pdf

https://www.geeksforgeeks.org/constraint-satisfaction-problems-csp-in-artificial-intelligence/

https://www.javatpoint.com/constraint-satisfaction-problems-in-artificial-intelligence

https://www.appliedaicourse.com/blog/constraint-satisfaction-problems-csp-in-artificial-intelligence/
"""