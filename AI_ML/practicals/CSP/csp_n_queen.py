# -*- coding: utf-8 -*-
"""csp_n_queen.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GyTud7U3X002HSxiw7YLUS_VugCZFvqE
"""

class NQueen:
    def __init__(self, n):
        #self.solution = {row:0 for row in range(1,9)}
        self.solution           =   [-1 for row in range(1, n+1)]
        self.occupiedColumns    =   set()
        self.occupiedPDiagonals  =   set()
        self.occupiedSDiagonals  =   set()
        self.maxRowIndex        =   n-1
        self.maxColIndex        =   n-1
        self.minRowIndex        =   0
        self.minColIndex        =   0

    def getDiagonals(self, row, col):
      return (row - col, row + col - 1)

    # constraint-1 : different column
    def isSameColumn(self, currentCol):
        if currentCol in self.occupiedColumns:
            return True
        return False

    # constraint-2 : different diagonal
    def isSameDiagonal(self, currentRow, currentCol):
        d1, d2 = self.getDiagonals(currentRow, currentCol)
        if d1 in self.occupiedPDiagonals:
            return True
        elif d2 in self.occupiedSDiagonals:
            return True
        else:
          return False

    # check all constraints
    def checkConstraints(self, r, c):
        if self.isSameColumn(c):
            return False
        elif self.isSameDiagonal(r, c):
            return False
        else:
            return True


    # move to next state
    def getNextPosition(self, currentRow):
      nextAvailableColPosition  =   self.solution[currentRow] + 1

      while(nextAvailableColPosition<=self.maxColIndex):
        if(self.checkConstraints(currentRow, nextAvailableColPosition)):
          return nextAvailableColPosition
        else:
          nextAvailableColPosition += 1

      return -1

    def saveSolution(self, row, col):
      self.solution[row] = col
      d1, d2 = self.getDiagonals(row, col)
      self.occupiedColumns.add(col)
      self.occupiedPDiagonals.add(d1)
      self.occupiedSDiagonals.add(d2)

    def backTrack(self, rowIndex):
      d1, d2 = self.getDiagonals(rowIndex, self.solution[rowIndex])
      self.solution[rowIndex+1] = -1
      self.occupiedColumns.remove(self.solution[rowIndex])
      self.occupiedPDiagonals.remove(d1)
      self.occupiedSDiagonals.remove(d2)


    def solve(self):
      currentRowIndex = 0;
      while(self.solution[0] <= self.maxColIndex):
        nextAvailableColPosition = self.getNextPosition(currentRowIndex)
        if(nextAvailableColPosition==-1 and currentRowIndex!=0):
          currentRowIndex -= 1
          self.backTrack(currentRowIndex)
        elif(nextAvailableColPosition==-1):
          return False
        elif(currentRowIndex == self.maxRowIndex):
          self.saveSolution(currentRowIndex, nextAvailableColPosition)
          return True
        else:
          self.saveSolution(currentRowIndex, nextAvailableColPosition)
          currentRowIndex += 1

      return False

ob = NQueen(7)
print(ob.solve())
print(ob.solution)